{"name": "test_get_eye_intent", "status": "broken", "statusDetails": {"message": "UnicodeEncodeError: 'gbk' codec can't encode character '\\U0001f602' in position 81: illegal multibyte sequence", "trace": "self = <test_get_intent.TestIntent object at 0x000002420FD70470>\napi_url = '10.14.250.220:8062/intention/v1?utterance={}&enterprise=ophthalmology&multi_intent_mode=False'\ntarget_file = 'eye_intent.csv'\ntest_data_file = 'ophthalmology_intention_to_test_7000.csv'\nresult_file = 'eye_intent_test_result.xls'\n\n    def get_eye_intent(self, api_url, target_file, test_data_file, result_file):\n        \"\"\"\n        通过抽取测试集的数据，调用意图接口，得出的测试结果，在调用函数获取每个target的准确率，召回率，F1\n        :param target_file: 储存target的文件\n        :param data_file: 储存接口结果数据的文件\n        \"\"\"\n        # 获取测试集的data\n        test_data = ChangeDataType.csv_to_dict(rootPath + \"\\\\testdata\\\\apidata\\\\\" + test_data_file)\n        score_list = []\n        re_intent_list = []\n        exp_intent_list = []\n        tf_list = []\n        re_intent = \"\"\n        tf = \"\"\n        # 循环读取sentence，intent\n        for idx, temp in test_data.iterrows():\n            intent = temp[\"intention\"]\n            sentence = temp[\"sentence\"]\n            # 发起请求\n            url = api_url.format(sentence)\n            try:\n>               r = requests.get(url, timeout=50)\n\n..\\api\\get_intent.py:131: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nurl = '10.14.250.220:8062/intention/v1?utterance=😂那我用了纯净水冲洗会怎么样？&enterprise=ophthalmology&multi_intent_mode=False'\nparams = None, kwargs = {'allow_redirects': True, 'timeout': 50}\n\n    def get(url, params=None, **kwargs):\n        r\"\"\"Sends a GET request.\n    \n        :param url: URL for the new :class:`Request` object.\n        :param params: (optional) Dictionary, list of tuples or bytes to send\n            in the query string for the :class:`Request`.\n        :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n        :return: :class:`Response <Response>` object\n        :rtype: requests.Response\n        \"\"\"\n    \n        kwargs.setdefault('allow_redirects', True)\n>       return request('get', url, params=params, **kwargs)\n\nE:\\Python3.7.3\\lib\\site-packages\\requests\\api.py:76: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nmethod = 'get'\nurl = '10.14.250.220:8062/intention/v1?utterance=😂那我用了纯净水冲洗会怎么样？&enterprise=ophthalmology&multi_intent_mode=False'\nkwargs = {'allow_redirects': True, 'params': None, 'timeout': 50}\nsession = <requests.sessions.Session object at 0x000002420FD70588>\n\n    def request(method, url, **kwargs):\n        \"\"\"Constructs and sends a :class:`Request <Request>`.\n    \n        :param method: method for the new :class:`Request` object: ``GET``, ``OPTIONS``, ``HEAD``, ``POST``, ``PUT``, ``PATCH``, or ``DELETE``.\n        :param url: URL for the new :class:`Request` object.\n        :param params: (optional) Dictionary, list of tuples or bytes to send\n            in the query string for the :class:`Request`.\n        :param data: (optional) Dictionary, list of tuples, bytes, or file-like\n            object to send in the body of the :class:`Request`.\n        :param json: (optional) A JSON serializable Python object to send in the body of the :class:`Request`.\n        :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.\n        :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.\n        :param files: (optional) Dictionary of ``'name': file-like-objects`` (or ``{'name': file-tuple}``) for multipart encoding upload.\n            ``file-tuple`` can be a 2-tuple ``('filename', fileobj)``, 3-tuple ``('filename', fileobj, 'content_type')``\n            or a 4-tuple ``('filename', fileobj, 'content_type', custom_headers)``, where ``'content-type'`` is a string\n            defining the content type of the given file and ``custom_headers`` a dict-like object containing additional headers\n            to add for the file.\n        :param auth: (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth.\n        :param timeout: (optional) How many seconds to wait for the server to send data\n            before giving up, as a float, or a :ref:`(connect timeout, read\n            timeout) <timeouts>` tuple.\n        :type timeout: float or tuple\n        :param allow_redirects: (optional) Boolean. Enable/disable GET/OPTIONS/POST/PUT/PATCH/DELETE/HEAD redirection. Defaults to ``True``.\n        :type allow_redirects: bool\n        :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.\n        :param verify: (optional) Either a boolean, in which case it controls whether we verify\n                the server's TLS certificate, or a string, in which case it must be a path\n                to a CA bundle to use. Defaults to ``True``.\n        :param stream: (optional) if ``False``, the response content will be immediately downloaded.\n        :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.\n        :return: :class:`Response <Response>` object\n        :rtype: requests.Response\n    \n        Usage::\n    \n          >>> import requests\n          >>> req = requests.request('GET', 'https://httpbin.org/get')\n          >>> req\n          <Response [200]>\n        \"\"\"\n    \n        # By using the 'with' statement we are sure the session is closed, thus we\n        # avoid leaving sockets open which can trigger a ResourceWarning in some\n        # cases, and look like a memory leak in others.\n        with sessions.Session() as session:\n>           return session.request(method=method, url=url, **kwargs)\n\nE:\\Python3.7.3\\lib\\site-packages\\requests\\api.py:61: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <requests.sessions.Session object at 0x000002420FD70588>, method = 'get'\nurl = '10.14.250.220:8062/intention/v1?utterance=😂那我用了纯净水冲洗会怎么样？&enterprise=ophthalmology&multi_intent_mode=False'\nparams = None, data = None, headers = None, cookies = None, files = None\nauth = None, timeout = 50, allow_redirects = True, proxies = {}, hooks = None\nstream = None, verify = None, cert = None, json = None\n\n    def request(self, method, url,\n            params=None, data=None, headers=None, cookies=None, files=None,\n            auth=None, timeout=None, allow_redirects=True, proxies=None,\n            hooks=None, stream=None, verify=None, cert=None, json=None):\n        \"\"\"Constructs a :class:`Request <Request>`, prepares it and sends it.\n        Returns :class:`Response <Response>` object.\n    \n        :param method: method for the new :class:`Request` object.\n        :param url: URL for the new :class:`Request` object.\n        :param params: (optional) Dictionary or bytes to be sent in the query\n            string for the :class:`Request`.\n        :param data: (optional) Dictionary, list of tuples, bytes, or file-like\n            object to send in the body of the :class:`Request`.\n        :param json: (optional) json to send in the body of the\n            :class:`Request`.\n        :param headers: (optional) Dictionary of HTTP Headers to send with the\n            :class:`Request`.\n        :param cookies: (optional) Dict or CookieJar object to send with the\n            :class:`Request`.\n        :param files: (optional) Dictionary of ``'filename': file-like-objects``\n            for multipart encoding upload.\n        :param auth: (optional) Auth tuple or callable to enable\n            Basic/Digest/Custom HTTP Auth.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple\n        :param allow_redirects: (optional) Set to True by default.\n        :type allow_redirects: bool\n        :param proxies: (optional) Dictionary mapping protocol or protocol and\n            hostname to the URL of the proxy.\n        :param stream: (optional) whether to immediately download the response\n            content. Defaults to ``False``.\n        :param verify: (optional) Either a boolean, in which case it controls whether we verify\n            the server's TLS certificate, or a string, in which case it must be a path\n            to a CA bundle to use. Defaults to ``True``.\n        :param cert: (optional) if String, path to ssl client cert file (.pem).\n            If Tuple, ('cert', 'key') pair.\n        :rtype: requests.Response\n        \"\"\"\n        # Create the Request.\n        req = Request(\n            method=method.upper(),\n            url=url,\n            headers=headers,\n            files=files,\n            data=data or {},\n            json=json,\n            params=params or {},\n            auth=auth,\n            cookies=cookies,\n            hooks=hooks,\n        )\n        prep = self.prepare_request(req)\n    \n        proxies = proxies or {}\n    \n        settings = self.merge_environment_settings(\n            prep.url, proxies, stream, verify, cert\n        )\n    \n        # Send the request.\n        send_kwargs = {\n            'timeout': timeout,\n            'allow_redirects': allow_redirects,\n        }\n        send_kwargs.update(settings)\n>       resp = self.send(prep, **send_kwargs)\n\nE:\\Python3.7.3\\lib\\site-packages\\requests\\sessions.py:530: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <requests.sessions.Session object at 0x000002420FD70588>\nrequest = <PreparedRequest [GET]>\nkwargs = {'cert': None, 'proxies': OrderedDict(), 'stream': False, 'timeout': 50, ...}\nallow_redirects = True, stream = False, hooks = {'response': []}\n\n    def send(self, request, **kwargs):\n        \"\"\"Send a given PreparedRequest.\n    \n        :rtype: requests.Response\n        \"\"\"\n        # Set defaults that the hooks can utilize to ensure they always have\n        # the correct parameters to reproduce the previous request.\n        kwargs.setdefault('stream', self.stream)\n        kwargs.setdefault('verify', self.verify)\n        kwargs.setdefault('cert', self.cert)\n        kwargs.setdefault('proxies', self.proxies)\n    \n        # It's possible that users might accidentally send a Request object.\n        # Guard against that specific failure case.\n        if isinstance(request, Request):\n            raise ValueError('You can only send PreparedRequests.')\n    \n        # Set up variables needed for resolve_redirects and dispatching of hooks\n        allow_redirects = kwargs.pop('allow_redirects', True)\n        stream = kwargs.get('stream')\n        hooks = request.hooks\n    \n        # Get the appropriate adapter to use\n>       adapter = self.get_adapter(url=request.url)\n\nE:\\Python3.7.3\\lib\\site-packages\\requests\\sessions.py:637: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <requests.sessions.Session object at 0x000002420FD70588>\nurl = '10.14.250.220:8062/intention/v1?utterance=😂那我用了纯净水冲洗会怎么样？&enterprise=ophthalmology&multi_intent_mode=False'\n\n    def get_adapter(self, url):\n        \"\"\"\n        Returns the appropriate connection adapter for the given URL.\n    \n        :rtype: requests.adapters.BaseAdapter\n        \"\"\"\n        for (prefix, adapter) in self.adapters.items():\n    \n            if url.lower().startswith(prefix.lower()):\n                return adapter\n    \n        # Nothing matches :-/\n>       raise InvalidSchema(\"No connection adapters were found for {!r}\".format(url))\nE       requests.exceptions.InvalidSchema: No connection adapters were found for '10.14.250.220:8062/intention/v1?utterance=😂那我用了纯净水冲洗会怎么样？&enterprise=ophthalmology&multi_intent_mode=False'\n\nE:\\Python3.7.3\\lib\\site-packages\\requests\\sessions.py:728: InvalidSchema\n\nDuring handling of the above exception, another exception occurred:\n\nself = <test_get_intent.TestIntent object at 0x000002420FD70470>\n\n    @pytest.mark.eyeintenttest\n    @allure.feature(\"意图识别\")\n    def test_get_eye_intent(self):\n        # GetIntent.get_intent(self, \"intent_tag.txt\", \"意图识别.csv\", \"intent_test_result.xls\")\n        GetIntent.get_eye_intent(self,\n                                 \"10.14.250.220:8062/intention/v1?utterance={}&enterprise=ophthalmology&multi_intent_mode=False\",\n                                 \"eye_intent.csv\",\n                                 \"ophthalmology_intention_to_test_7000.csv\",\n>                                \"eye_intent_test_result.xls\")\n\napi\\test_get_intent.py:24: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <test_get_intent.TestIntent object at 0x000002420FD70470>\napi_url = '10.14.250.220:8062/intention/v1?utterance={}&enterprise=ophthalmology&multi_intent_mode=False'\ntarget_file = 'eye_intent.csv'\ntest_data_file = 'ophthalmology_intention_to_test_7000.csv'\nresult_file = 'eye_intent_test_result.xls'\n\n    def get_eye_intent(self, api_url, target_file, test_data_file, result_file):\n        \"\"\"\n        通过抽取测试集的数据，调用意图接口，得出的测试结果，在调用函数获取每个target的准确率，召回率，F1\n        :param target_file: 储存target的文件\n        :param data_file: 储存接口结果数据的文件\n        \"\"\"\n        # 获取测试集的data\n        test_data = ChangeDataType.csv_to_dict(rootPath + \"\\\\testdata\\\\apidata\\\\\" + test_data_file)\n        score_list = []\n        re_intent_list = []\n        exp_intent_list = []\n        tf_list = []\n        re_intent = \"\"\n        tf = \"\"\n        # 循环读取sentence，intent\n        for idx, temp in test_data.iterrows():\n            intent = temp[\"intention\"]\n            sentence = temp[\"sentence\"]\n            # 发起请求\n            url = api_url.format(sentence)\n            try:\n                r = requests.get(url, timeout=50)\n                result = r.json()\n                re_intent = result[\"data\"][\"intent\"]  # 获取返回data的intent\n                print(re_intent)\n                score = result[\"data\"][\"intent_probability\"]  # 获取返回data的score\n                tf = CommonFunction.get_tf(intent, re_intent)\n            except Exception as e:\n                score = \"bad request\"\n>               print(e)\nE               UnicodeEncodeError: 'gbk' codec can't encode character '\\U0001f602' in position 81: illegal multibyte sequence\n\n..\\api\\get_intent.py:139: UnicodeEncodeError"}, "start": 1586853270656, "stop": 1586853271424, "uuid": "fb2d5aa3-890c-44db-a0b1-140d271a5d01", "historyId": "fcf95f8489dbdfca543f9a4451eb4a84", "testCaseId": "6c84bbb7e38c55ecc537e59b43df1660", "fullName": "pytest.api.test_get_intent.TestIntent#test_get_eye_intent", "labels": [{"name": "feature", "value": "意图识别"}, {"name": "tag", "value": "eyeintenttest"}, {"name": "parentSuite", "value": "pytest.api"}, {"name": "suite", "value": "test_get_intent"}, {"name": "subSuite", "value": "TestIntent"}, {"name": "host", "value": "WIN-OQ20V7UABJF"}, {"name": "thread", "value": "21316-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "pytest.api.test_get_intent"}]}